/*
 * Author: Nicole Whitehead
 * 
 * Take in the grammar string generated by the FileParser and Grammar class,
 * then can draw the interpretation of the string to the screen. 
 */

import javax.media.opengl.*;
import javax.media.opengl.glu.*;


public class GrammarInterpreter {
	double length;
	double angle;
	double deltaH = 0.02;
	double deltaW = 0.01;
	String grammar;
	GLUquadric quad;
	
	public GrammarInterpreter(String dna, double inLen, double inAngle)
	{
		grammar = dna;
		length =  inLen;
		angle =  inAngle; 
		
		
	}
	
	public void drawGrammar(GL gl, GLU glu) {
		
		quad = glu.gluNewQuadric();
		for(int i = 0; i < grammar.length(); i++) {
			char c = grammar.charAt(i); 
			
			switch(c) {
			case 'F':
				drawF(gl, glu, quad);
				break;
			case '[':
				drawLeftBracket(gl); 
				break; 
			case ']':
				drawRightBracket(gl); 
				break;
			case 'L':
				drawL(gl); 
				break; 
			case 'W':
				drawW(gl);
				break;
			case 'X':
				drawX(gl);
				break;
			case 'A':
				drawA(gl); 
				break;
			case 'Y':
				drawY(gl);
				break;
			case 'B':
				drawB(gl);
				break;
			case 'Z':
				drawZ(gl);
				break;
			case 'C':
				drawC(gl); 
				break;
			default:
				break; 
			}
		}
	}

	/*
	 * Draw the negative Z rotation
	 */
	private void drawC(GL gl) {
		gl.glRotated(-angle, 1.0d, 0.0d, 0.0d); 
	}

	/*
	 * Draw the positive Z rotation
	 */
	private void drawZ(GL gl) {
		gl.glRotated(angle, 1.0d, 0.0d, 0.0d); 
	}

	/*
	 * Draw the negative Y rotation
	 */
	private void drawB(GL gl) {
		gl.glRotated(-angle, 0.0d, 0.0d, 1.0d); 
	}

	/*
	 * Draw the positive Y rotation
	 */
	private void drawY(GL gl) {
		gl.glRotated(angle, 0.0d, 0.0d, 1.0d); 
	}

	/*
	 * Draw the negative Y rotation
	 */
	private void drawA(GL gl) {
		gl.glRotated(-angle, 0.0d, 1.0d, 0.0d); 
	}

	/*
	 * Draw the positive X rotation
	 */
	private void drawX(GL gl) {
		gl.glRotated(angle, 0.0d, 1.0d, 0.0d); 		
	}

	/*
	 * Draw a flower
	 */
	private void drawW(GL gl) {
		//stub currently
	}

	/*
	 * Draw a leaf
	 */
	private void drawL(GL gl) 
	{
		gl.glNormal3d(0, 0, 1);
		gl.glColor3d(0.6f, 0.8f, 0.5f); 
		gl.glBegin(GL.GL_LINES);
			gl.glVertex3d(0.0f, 0.0f, 0.0025f*deltaH);
			gl.glVertex3d(0.0f, 1.0f*deltaH, 0.0025f*deltaH); 
		gl.glEnd(); 
		
		
		gl.glBegin(GL.GL_POLYGON);
			gl.glVertex3d(0.0f, 0.0f, 0.0f); 
			gl.glVertex3d(-0.1f*deltaH, 0.125f*deltaH, 0.0f); 
			gl.glVertex3d(-0.2f*deltaH, 0.2f*deltaH, 0.0f); 
			gl.glVertex3d(-0.25f*deltaH, 0.5f*deltaH, 0.0f); 
			gl.glVertex3d(-0.25f*deltaH, 0.75f*deltaH, 0.0f); 
			gl.glVertex3d(-0.125f*deltaH, 0.925f*deltaH, 0.0f);
			gl.glVertex3d(0.0f, 1.0f*deltaH, 0.0f);
			gl.glVertex3d(0.125f*deltaH, 0.925f*deltaH, 0.0f);
			gl.glVertex3d(0.25f*deltaH, 0.75f*deltaH, 0.0f);
			gl.glVertex3d(0.25f*deltaH, 0.5f*deltaH, 0.0f);
			gl.glVertex3d(0.2f*deltaH, 0.2f*deltaH, 0.0f);
			gl.glVertex3d(0.1f*deltaH, 0.125f*deltaH, 0.0f); 
			gl.glVertex3d(0.1f*deltaH, 1.0f*deltaH, 0.0f);
		gl.glEnd();
	}

	/*
	 * Pop the matrix
	 */
	private void drawRightBracket(GL gl) {
		gl.glPopMatrix(); 		
	}

	/*
	 * Push the matrix
	 */
	private void drawLeftBracket(GL gl) {
		gl.glPushMatrix(); 
	}

	/*
	 * Draw forward delta length
	 */
	private void drawF(GL gl, GLU glu, GLUquadric quad) {
		gl.glColor3d(0.25d, 0.65d, 0.4d);
		
		//glu.gluCylinder(quad, 0.0002d, 0.0002d, length, 10, 30);
		gl.glLineWidth(4.0f);
		
		gl.glBegin(GL.GL_LINES);
			gl.glVertex3d(0.0d, 0.0d, 0.0d);
			gl.glVertex3d(0.0d, length, 0.0d); 
		gl.glEnd();
	
		gl.glTranslated(0,length, 0);
		
	}
	
}
